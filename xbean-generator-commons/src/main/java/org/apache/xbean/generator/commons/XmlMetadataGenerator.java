/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.xbean.generator.commons;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;

import org.apache.xbean.generator.*;
import org.apache.xbean.generator.artifact.SimpleArtifact;
import org.apache.xbean.model.mapping.*;
import org.apache.xbean.namespace.NamespaceDiscoverer;

/**
 * @author Dain Sundstrom
 * @version $Id$
 * @since 1.0
 */
public abstract class XmlMetadataGenerator implements GeneratorPlugin {

    private final String namespaceHandler;
    private final NamespaceDiscoverer namespaceDiscoverer;
    private final File destination;
    private final ArtifactSet artifactSet;
    private final LogFacade log;

    protected XmlMetadataGenerator(String namespaceHandler, NamespaceDiscoverer namespaceDiscoverer, File destination, ArtifactSet artifactSet, LogFacade logFacade) {
        this.namespaceHandler = namespaceHandler;
        this.namespaceDiscoverer = namespaceDiscoverer;
        this.destination = destination;
        this.artifactSet = artifactSet;
        this.log = logFacade;
    }

    public void generate(NamespaceMapping namespaceMapping, Map<String, String> configuration) throws IOException {
        String namespace = namespaceMapping.getNamespace();
        if (namespace == null) {
            return;
        }

        File file = new File(destination, namespaceDiscoverer.createDiscoveryPathName(namespace));
        file.getParentFile().mkdirs();
        log.log("Generating META-INF properties file: " + file + " for namespace: " + namespace);
        PrintWriter out = new PrintWriter(new FileWriter(file));
        try {
            generatePropertiesFile(out, namespaceMapping.getElements());
            artifactSet.register(new SimpleArtifact(file, false, Collections.singletonMap("type", "xbean")));
        } finally {
            out.close();
        }
    }

    private void generatePropertiesFile(PrintWriter out, Set<ElementMapping> elements) {
        out.println("# NOTE: this file is autogenerated by Apache XBean");
        out.println();
        out.println("# beans");

        for (ElementMapping element : elements) {
            out.println(element.getElementName() + " = " + element.getClassName());

            generatePropertiesFileContent(out, element);
            generatePropertiesFilePropertyAliases(out, element);
            generatePropertiesFileConstructors(out, element);
            out.println();
        }
    }

    private void generatePropertiesFileContent(PrintWriter out, ElementMapping element) {
        String contentProperty = element.getContentProperty();
        if (contentProperty != null) {
            out.println(element.getElementName() + ".contentProperty = " + contentProperty);
        }
        String initMethod = element.getInitMethod();
        if (initMethod != null) {
            out.println(element.getElementName() + ".initMethod = " + initMethod);
        }

        String destroyMethod = element.getDestroyMethod();
        if (destroyMethod != null) {
            out.println(element.getElementName() + ".destroyMethod = " + destroyMethod);
        }

        String factoryMethod = element.getFactoryMethod();
        if (factoryMethod != null) {
            out.println(element.getElementName() + ".factoryMethod = " + factoryMethod);
        }

        for (AttributeMapping attribute : element.getAttributes()) {
            if (attribute.getPropertyEditor() != null) {
                out.println(element.getElementName() + "." + attribute.getPropertyName() + ".propertyEditor = " + attribute.getPropertyEditor());
            }
        }

        List<String> flatProperties = element.getFlatProperties();
        for (String flatProperty : flatProperties) {
            out.println(element.getElementName() + "." + flatProperty + ".flat");
        }

        Map<String, MapMapping> maps = element.getMapMappings();
        for (Map.Entry<String, MapMapping> entry : maps.entrySet()) {
            MapMapping mm = entry.getValue();
            if (mm.getEntryName() != null) {
                out.println(element.getElementName() + "." + entry.getKey() + ".map.entryName = " + mm.getEntryName());
            }
            if (mm.getKeyName() != null) {
                out.println(element.getElementName() + "." + entry.getKey() + ".map.keyName = " + mm.getKeyName());
            }
            if (mm.isFlat()) {
                out.println(element.getElementName() + "." + entry.getKey() + ".map.flat = " + Boolean.toString(mm.isFlat()));
            }
            if (mm.getDupsMode() != null) {
                out.println(element.getElementName() + "." + entry.getKey() + ".map.dups = " + mm.getDupsMode());
            }
            if (mm.getDefaultKey() != null) {
                out.println(element.getElementName() + "." + entry.getKey() + ".map.defaultKey = " + mm.getDefaultKey());
            }
        }

        Map<String, String> flatCollections = element.getFlatCollections();
        for (Map.Entry<String, String> entry : flatCollections.entrySet()) {
            String child = entry.getValue();
            out.println(element.getElementName() + "." + child + ".flatCollection = " + entry.getKey());
        }
    }

    private void generatePropertiesFileConstructors(PrintWriter out, ElementMapping element) {
        List<List<ParameterMapping>> constructors = element.getConstructors();
        for (List<ParameterMapping> constructor : constructors) {
            generatePropertiesFileConstructor(out, element, constructor);
        }
    }

    private void generatePropertiesFileConstructor(PrintWriter out, ElementMapping element, List<ParameterMapping> args) {
        out.print(element.getClassName());
        if (element.getFactoryMethod() != null) {
            out.print("." + element.getFactoryMethod());
        }
        out.print("(");
        for (Iterator<ParameterMapping> iterator = args.iterator(); iterator.hasNext();) {
            ParameterMapping parameterMapping = iterator.next();
            out.print(parameterMapping.getType().getName());
            if (iterator.hasNext()) {
                out.print(",");
            }
        }
        out.print(").parameterNames =");
        for (ParameterMapping parameterMapping : args) {
            out.print(" ");
            out.print(parameterMapping.getName());
        }
        out.println();
    }

    private void generatePropertiesFilePropertyAliases(PrintWriter out, ElementMapping element) {
        for (Iterator iterator = element.getAttributes().iterator(); iterator.hasNext();) {
            AttributeMapping attributeMapping = (AttributeMapping) iterator.next();
            String propertyName = attributeMapping.getPropertyName();
            String attributeName = attributeMapping.getAttributeName();
            if (!propertyName.equals(attributeName)) {
                if (List.class.getName().equals(attributeMapping.getType().getName())) {
                    out.println(element.getElementName() + ".list." + attributeName + " = " + propertyName);
                } else {
                    out.println(element.getElementName() + ".alias." + attributeName + " = " + propertyName);
                }
            }
        }
    }

    public LogFacade getLog() {
        return log;
    }

    public void setLog(LogFacade log) {
    }
}
