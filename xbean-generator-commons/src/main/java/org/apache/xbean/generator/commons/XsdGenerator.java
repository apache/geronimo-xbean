/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.xbean.generator.commons;

import org.apache.ws.commons.schema.*;
import org.apache.ws.commons.schema.constants.Constants;
import org.apache.xbean.generator.*;
import org.apache.xbean.generator.artifact.SimpleArtifact;
import org.apache.xbean.generator.commons.dom.VirtualNodeList;
import org.apache.xbean.generator.commons.schema.Builder;
import org.w3c.dom.CDATASection;
import org.w3c.dom.Document;

import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

/**
 * @author Dain Sundstrom
 * @version $Id$
 * @since 1.0
 */
public abstract class XsdGenerator implements GeneratorPlugin {

    private final File destFile;
    private final ArtifactSet artifactSet;
    private final LogFacade log;
    private boolean strictOrder;

    private Builder builder;

    protected XsdGenerator(File destFile, ArtifactSet artifactSet, LogFacade logFacade) {
        this(true, destFile, artifactSet, logFacade);
    }

    protected XsdGenerator(boolean strictOrder, File destFile, ArtifactSet artifactSet, LogFacade logFacade) {
        this.destFile = destFile;
        this.strictOrder = strictOrder;
        this.artifactSet = artifactSet;
        this.log = logFacade;
    }

    public void generate(NamespaceMapping namespaceMapping, Map<String, String> configuration) throws IOException {
        // TODO can only handle 1 schema document so far...
        String namespace = namespaceMapping.getNamespace();
        String fileName = new NamespaceFileNameExtractor().apply(namespace);

        this.strictOrder = Boolean.parseBoolean(configuration.getOrDefault("xsd.strictOrder", "true"));

        File file = new File(destFile, fileName);
        log.log("Generating XSD file: " + file + " for namespace: " + namespace);
        PrintWriter out = new PrintWriter(new FileWriter(file));

        try {
            generateSchema(out, namespaceMapping);
            Map<String, String> metadata = new HashMap<String, String>();
            metadata.put("type", "xsd");
            metadata.put("namespace", namespace);
            artifactSet.register(new SimpleArtifact(file, true, metadata));
        } finally {
            out.close();
        }
    }

    public void generateSchema(PrintWriter out, NamespaceMapping namespaceMapping) throws IOException {
        try {
            createSchema(namespaceMapping).write(out);
        } catch (ParserConfigurationException e) {
            throw new IOException(e);
        }
    }

    private XmlSchema createSchema(NamespaceMapping namespaceMapping) throws ParserConfigurationException {
        this.builder = new Builder();
        XmlSchema schema = builder.createSchema(namespaceMapping.getNamespace());

        builder.createAnnotation(schema, () -> "NOTE: this file is autogenerated by Apache XBean");

        for (ElementMapping element : namespaceMapping.getElements()) {
            generateElementMapping(schema, namespaceMapping, element);
        }
        return schema;
    }

    private void generateElementMapping(XmlSchema schema, NamespaceMapping namespaceMapping, ElementMapping mapping) {
        XmlSchemaElement element = new XmlSchemaElement(schema, true);
        element.setName(mapping.getElementName());

        builder.createAnnotation(element, mapping.getDescription());

        int complexCount = 0;
        for (AttributeMapping attributeMapping : mapping.getAttributes()) {
            if (!namespaceMapping.isSimpleType(attributeMapping.getType())) {
                complexCount++;
            }
        }

        XmlSchemaComplexType complexType = new XmlSchemaComplexType(schema, false);
        element.setType(complexType);

        if (complexCount > 0) {
            Supplier<List> itemsSupplier;
            if(strictOrder) {
                XmlSchemaSequence seq = new XmlSchemaSequence();
                complexType.setParticle(seq);

                seq.getItems().add(builder.unboundedAny());

                itemsSupplier = seq::getItems;
            } else {
                XmlSchemaChoice choice = builder.choice(0, Long.MAX_VALUE);
                complexType.setParticle(choice);

                XmlSchemaChoice inner = builder.choice();
                choice.getItems().add(inner);

                itemsSupplier = inner::getItems;
            }

            for (AttributeMapping attributeMapping : mapping.getAttributes()) {
                if (!namespaceMapping.isSimpleType(attributeMapping.getType())) {
                    generateElementMappingComplexProperty(schema, itemsSupplier, namespaceMapping, attributeMapping);
                }
            }

            itemsSupplier.get().add(builder.unboundedAny());

        }

        for (AttributeMapping attributeMapping : mapping.getAttributes()) {
            if (namespaceMapping.isSimpleType(attributeMapping.getType())) {
                generateElementMappingSimpleProperty(schema, complexType, attributeMapping);
            } else if (!attributeMapping.getType().isCollection()) {
                generateElementMappingComplexPropertyAsRef(schema, complexType, attributeMapping);
            }
        }

        generateIDAttributeMapping(schema, complexType, namespaceMapping, mapping);
        complexType.setAnyAttribute(builder.anyAttributeLax());
    }

    private void generateIDAttributeMapping(XmlSchema schema, XmlSchemaComplexType complexType, NamespaceMapping namespaceMapping, ElementMapping element) {
        for (AttributeMapping attributeMapping : element.getAttributes()) {
            if ("id".equals(attributeMapping.getAttributeName())) {
                return;
            }
        }

        XmlSchemaAttribute attribute = new XmlSchemaAttribute(schema, false);
        attribute.setName("id");
        attribute.setSchemaTypeName(Constants.XSD_ID);

        complexType.getAttributes().add(attribute);
    }

    private void generateElementMappingSimpleProperty(XmlSchema schema, XmlSchemaComplexType complexType, AttributeMapping attributeMapping) {
        // types with property editors need to be xs:string in the schema to validate
        QName type = attributeMapping.getPropertyEditor() != null ?
                Utils.getXsdType(Type.newSimpleType(String.class.getName())) : Utils.getXsdType(attributeMapping.getType());
        XmlSchemaAttribute attribute = new XmlSchemaAttribute(schema, false);
        complexType.getAttributes().add(attribute);

        builder.createAnnotation(attribute, attributeMapping.getDescription());

        attribute.setName(attributeMapping.getAttributeName());
        attribute.setSchemaTypeName(type);
    }

    private void generateElementMappingComplexPropertyAsRef(XmlSchema schema, XmlSchemaComplexType complexType, AttributeMapping attributeMapping) {
        XmlSchemaAttribute attribute = new XmlSchemaAttribute(schema, false);
        complexType.getAttributes().add(attribute);

        builder.createAnnotation(attribute, attributeMapping.getDescription());

        attribute.setName(attributeMapping.getAttributeName());
        attribute.setSchemaTypeName(Constants.XSD_STRING);
    }

    private void generateElementMappingComplexProperty(XmlSchema schema, Supplier<List> items, NamespaceMapping namespaceMapping, AttributeMapping attributeMapping) {
        Type type = attributeMapping.getType();
        List<ElementMapping> types;
        if (type.isCollection()) {
            types = Utils.findImplementationsOf(namespaceMapping, type.getNestedType());
        } else {
            types = Utils.findImplementationsOf(namespaceMapping, type);
        }
        Long maxOccurs = type.isCollection() || "java.util.Map".equals(type.getName()) ? Long.MAX_VALUE : 1;

        XmlSchemaElement xmlSchemaElement = new XmlSchemaElement(schema, false);
        xmlSchemaElement.setName(attributeMapping.getAttributeName());
        xmlSchemaElement.setMinOccurs(0);
        xmlSchemaElement.setMaxOccurs(maxOccurs);
        items.get().add(xmlSchemaElement);

        builder.createAnnotation(xmlSchemaElement, attributeMapping.getDescription());

        XmlSchemaComplexType complexType = new XmlSchemaComplexType(schema, false);
        xmlSchemaElement.setType(complexType);

        if (types.isEmpty()) {
            XmlSchemaSequence sequence = new XmlSchemaSequence();
            complexType.setParticle(sequence);
            sequence.setMinOccurs(0);
            sequence.setMaxOccurs(maxOccurs);
            XmlSchemaAny any = new XmlSchemaAny();
            any.setMinOccurs(0);
            any.setMaxOccurs(Long.MAX_VALUE);
            sequence.getItems().add(any);
        } else {
            XmlSchemaChoice choice = new XmlSchemaChoice();
            choice.setMinOccurs(0);
            choice.setMaxOccurs(maxOccurs);

            complexType.setParticle(choice);

            for (ElementMapping element : types) {
                XmlSchemaElement inner = new XmlSchemaElement(schema, false);
                inner.getRef().setTargetQName(new QName(namespaceMapping.getNamespace(), element.getElementName()));
                choice.getItems().add(inner);
            }
            XmlSchemaAny any = new XmlSchemaAny();
            any.setNamespace("##other");
            choice.getItems().add(any);
        }
    }

    public LogFacade getLog() {
        return log;
    }

    public void setLog(LogFacade log) {

    }

}
